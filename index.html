<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>洛克人 – 完整版 (多關卡 + 蓄力 + 道具 + 血條 + 高畫質)</title>
  <style>
    body {margin:0;background:linear-gradient(to bottom, #001122, #000011);color:#fff;font-family:system-ui,sans-serif;display:flex;flex-direction:column;align-items:center;justify-content:center;height:100vh;overflow:hidden;}
    h1 {color:#00bfff;font-size:48px;margin:20px;text-shadow:0 0 30px #00bfff;}
    canvas {background:linear-gradient(to bottom, #111133, #000022);border:12px solid #00bfff;border-radius:24px;box-shadow:0 0 60px #00bfff,inset 0 0 40px rgba(0,191,255,0.1);}
    #ui {position:absolute;top:20px;left:20px;font-size:28px;text-shadow:0 0 10px #fff;}
    #level {position:absolute;top:20px;right:20px;font-size:28px;text-shadow:0 0 10px #fff;}
    .info {position:fixed;bottom:20px;color:#aaa;font-size:16px;text-align:center;}
  </style>
</head>
<body>
  <h1>洛克人完整版</h1>
  <div id="ui">
    <div>生命: <span id="lives">3</span></div>
    <div>分數: <span id="score">0</span></div>
  </div>
  <div id="level">關卡: <span id="currentLevel">1</span>/3</div>
  <canvas id="game" width="1200" height="500"></canvas>
  <p class="info">A/D移動 W跳 J長按蓄力射擊 • 滑鼠/觸控瞄準射擊 • 撿道具buff • 走到右邊進關</p>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    ctx.shadowBlur = 10;
    ctx.shadowColor = '#00bfff';

    const GRAVITY = 0.9;
    const JUMP_FORCE = -18;
    const MOVE_SPEED = 6;
    const MAX_CHARGE = 300; // 蓄力毫秒

    let level = 1;
    let player = {x: 100, y: 350, vx: 0, vy: 0, w: 45, h: 55, lives: 3, charge: 0, charging: false, powerups: {speed:1, shotPower:1}};
    let bullets = [];
    let enemies = [];
    let powerups = [];
    let platforms = [];
    let particles = [];
    let score = 0;
    let keys = {};
    let mouse = {x:0, y:0};
    let gameRunning = true;

    // 關卡數據 (3關，每關平台/敵人/道具不同)
    const levels = [
      // 關1: 簡單平台
      [
        {x:0, y:470, w:1200, h:30},
        {x:200, y:400, w:200, h:20},
        {x:500, y:350, w:150, h:20},
        {x:800, y:420, w:180, h:20},
        {x:1000, y:380, w:200, h:20}
      ],
      // 關2: 更多平台 + 陷阱
      [
        {x:0, y:470, w:1200, h:30},
        {x:150, y:420, w:120, h:20},
        {x:350, y:380, w:160, h:20},
        {x:550, y:340, w:140, h:20},
        {x:750, y:400, w:120, h:20},
        {x:950, y:360, w:250, h:20}
      ],
      // 關3: 密集平台 + Boss區
      [
        {x:0, y:470, w:1200, h:30},
        {x:100, y:430, w:100, h:20},
        {x:250, y:380, w:120, h:20},
        {x:400, y:330, w:100, h:20},
        {x:550, y:280, w:140, h:20},
        {x:750, y:380, w:120, h:20},
        {x:900, y:430, w:300, h:20}
      ]
    ];

    function loadLevel(l) {
      platforms = levels[l-1];
      enemies = [];
      powerups = [];
      // 隨機生成敵人/道具
      for (let i = 0; i < l * 3; i++) {
        enemies.push({x: Math.random()*400 + 800, y: 420, vx: -2 - l*0.5, hp: 1 + l, maxHp: 1 + l, w: 35, h: 45});
      }
      for (let i = 0; i < l; i++) {
        const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00'];
        powerups.push({x: Math.random()*400 + 600, y: Math.random()*200 + 200, color: colors[Math.floor(Math.random()*4)], w: 25, h: 25});
      }
    }

    loadLevel(1);

    // 事件
    document.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
    document.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
    canvas.addEventListener('mousemove', e => {
      const rect = canvas.getBoundingClientRect();
      mouse.x = e.clientX - rect.left;
      mouse.y = e.clientY - rect.top;
    });
    canvas.addEventListener('touchmove', e => {
      const rect = canvas.getBoundingClientRect();
      mouse.x = e.touches[0].clientX - rect.left;
      mouse.y = e.touches[0].clientY - rect.top;
    });

    function update() {
      if (!gameRunning) return;

      // 玩家移動
      player.vx = 0;
      if (keys['a']) player.vx = -MOVE_SPEED * player.powerups.speed;
      if (keys['d']) player.vx = MOVE_SPEED * player.powerups.speed;
      if ((keys['w'] || keys[' ']) && player.onGround) {
        player.vy = JUMP_FORCE;
        player.onGround = false;
      }
      player.charging = keys['j'];
      if (player.charging) {
        player.charge = Math.min(player.charge + 16, MAX_CHARGE * player.powerups.shotPower);
      } else if (player.charge > 0) {
        shoot();
      }

      player.vy += GRAVITY;
      player.x += player.vx;
      player.y += player.vy;

      // 平台碰撞
      player.onGround = false;
      platforms.forEach(p => {
        if (player.x < p.x + p.w && player.x + player.w > p.x &&
            player.y < p.y + p.h && player.y + player.h > p.y + player.vy) {
          if (player.vy > 0) {
            player.y = p.y - player.h;
            player.vy = 0;
            player.onGround = true;
          }
        }
      });

      // 邊界
      if (player.x < 0) player.x = 0;
      if (player.y > canvas.height) {
        player.lives--;
        respawn();
      }

      // 進關 (到右邊)
      if (player.x > canvas.width - 100) {
        level = Math.min(level + 1, 3);
        if (level > 3) {
          alert(`通關！最終分數：${score}`);
          location.reload();
        } else {
          loadLevel(level);
          player.x = 100;
          score += 1000 * level;
        }
        document.getElementById('currentLevel').textContent = level;
      }

      // 子彈
      bullets = bullets.filter(b => {
        b.x += b.vx;
        b.y += b.vy;
        return b.x > -50 && b.x < canvas.width + 50 && b.y > -50 && b.y < canvas.height + 50;
      });

      // 敵人
      enemies.forEach(e => {
        e.x += e.vx;
        if (e.x < -e.w) enemies = enemies.filter(en => en !== e);
      });

      // 子彈擊敵
      bullets.forEach((b, bi) => {
        enemies.forEach((e, ei) => {
          if (b.x < e.x + e.w && b.x + b.w > e.x && b.y < e.y + e.h && b.y + b.h > e.y) {
            e.hp -= player.charge / 50 + 1;
            bullets.splice(bi, 1);
            if (e.hp <= 0) {
              enemies.splice(ei, 1);
              score += 200;
              createParticles(e.x + e.w/2, e.y + e.h/2);
            }
          }
        });
      });

      // 敵撞玩家
      enemies.forEach(e => {
        if (player.x < e.x + e.w && player.x + player.w > e.x &&
            player.y < e.y + e.h && player.y + player.h > e.y) {
          player.lives--;
          respawn();
        }
      });

      // 撿道具
      powerups.forEach((pu, pi) => {
        if (player.x < pu.x + pu.w && player.x + player.w > pu.x &&
            player.y < pu.y + pu.h && player.y + player.h > pu.y) {
          powerups.splice(pi, 1);
          if (pu.color === '#ff0000') player.lives = Math.min(player.lives + 1, 5);
          if (pu.color === '#00ff00') score += 500;
          if (pu.color === '#0000ff') player.powerups.speed = 1.5;
          if (pu.color === '#ffff00') player.powerups.shotPower = 2;
          setTimeout(() => player.powerups.speed = 1, 10000);
          setTimeout(() => player.powerups.shotPower = 1, 15000);
          createParticles(pu.x + pu.w/2, pu.y + pu.h/2, pu.color);
        }
      });

      document.getElementById('score').textContent = score;
      document.getElementById('lives').textContent = player.lives;
    }

    function shoot() {
      const power = player.charge / MAX_CHARGE;
      const angle = Math.atan2(mouse.y - (player.y + player.h/2), mouse.x - (player.x + player.w/2));
      bullets.push({
        x: player.x + player.w/2,
        y: player.y + player.h/2,
        vx: Math.cos(angle) * (8 + power * 10),
        vy: Math.sin(angle) * (8 + power * 10),
        w: 8 + power * 8,
        h: 8 + power * 8
      });
      player.charge = 0;
    }

    function respawn() {
      player.x = 100;
      player.y = 350;
      player.vx = 0;
      player.vy = 0;
      player.charge = 0;
      if (player.lives <= 0) {
        alert(`遊戲結束！最終分數：${score}`);
        location.reload();
      }
    }

    function createParticles(x, y, color = '#ffff00') {
      for (let i = 0; i < 10; i++) {
        particles.push({
          x, y,
          vx: (Math.random() - 0.5) * 10,
          vy: (Math.random() - 0.5) * 10,
          life: 30,
          color
        });
      }
    }

    function updateParticles() {
      particles = particles.filter(p => {
        p.x += p.vx;
        p.y += p.vy;
        p.life--;
        p.vx *= 0.98;
        p.vy *= 0.98;
        return p.life > 0;
      });
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // 背景星星
      ctx.fillStyle = 'rgba(255,255,255,0.3)';
      for (let i = 0; i < 50; i++) {
        ctx.fillRect(Math.random()*canvas.width, Math.random()*canvas.height, 2, 2);
      }

      // 平台 (漸層)
      const grad = ctx.createLinearGradient(0, 0, 0, 30);
      grad.addColorStop(0, '#888');
      grad.addColorStop(1, '#444');
      ctx.fillStyle = grad;
      platforms.forEach(p => ctx.fillRect(p.x, p.y, p.w, p.h));

      // 玩家 (精美)
      const pGrad = ctx.createRadialGradient(player.x + player.w/2, player.y + player.h/2, 0, player.x + player.w/2, player.y + player.h/2, player.w);
      pGrad.addColorStop(0, '#00bfff');
      pGrad.addColorStop(1, '#0066aa');
      ctx.shadowBlur = 20;
      ctx.shadowColor = '#00bfff';
      ctx.fillStyle = pGrad;
      ctx.fillRect(player.x, player.y, player.w, player.h);
      ctx.shadowBlur = 0;

      // 蓄力條
      if (player.charging) {
        ctx.fillStyle = 'rgba(0,191,255,0.8)';
        ctx.fillRect(player.x, player.y - 20, (player.charge / MAX_CHARGE) * player.w, 8);
      }

      // 子彈 (發光)
      ctx.shadowBlur = 15;
      ctx.shadowColor = '#ffff00';
      bullets.forEach(b => {
        ctx.fillStyle = '#ffff00';
        ctx.beginPath();
        ctx.arc(b.x + b.w/2, b.y + b.h/2, b.w/2, 0, Math.PI*2);
        ctx.fill();
      });
      ctx.shadowBlur = 0;

      // 敵人 + 血條
      enemies.forEach(e => {
        const eGrad = ctx.createRadialGradient(e.x + e.w/2, e.y + e.h/2, 0, e.x + e.w/2, e.y + e.h/2, e.w);
        eGrad.addColorStop(0, '#ff4444');
        eGrad.addColorStop(1, '#aa0000');
        ctx.fillStyle = eGrad;
        ctx.fillRect(e.x, e.y, e.w, e.h);

        // 血條
        ctx.fillStyle = '#ff0000';
        ctx.fillRect(e.x, e.y - 10, e.w, 6);
        ctx.fillStyle = '#00ff00';
        ctx.fillRect(e.x, e.y - 10, (e.hp / e.maxHp) * e.w, 6);
      });

      // 道具
      powerups.forEach(pu => {
        ctx.shadowColor = pu.color;
        ctx.shadowBlur = 15;
        ctx.fillStyle = pu.color;
        ctx.beginPath();
        ctx.arc(pu.x + pu.w/2, pu.y + pu.h/2, pu.w/2, 0, Math.PI*2);
        ctx.fill();
      });
      ctx.shadowBlur = 0;

      // 粒子
      particles.forEach(p => {
        ctx.globalAlpha = p.life / 30;
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x, p.y, 4, 4);
      });
      ctx.globalAlpha = 1;

      updateParticles();
    }

    function loop() {
      update();
      draw();
      requestAnimationFrame(loop);
    }

    loop();
  </script>
</body>
</html>
